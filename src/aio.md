我理解的PaaS
IaaS：基础设施服务，Infrastructure-as-a-service

PaaS：平台服务，Platform-as-a-service

SaaS：软件服务，Software-as-a-service

借用阮一峰博客中提到的例子：卖披萨来说明这个事

你可以从头到尾，自己生产披萨，但是这样比较麻烦，需要准备的东西多，因此你决定外包一部分工作，采用他人的服务。你有三个方案。

方案1： IaaS, 他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。

方案2：PaaS, 除了基础设施，他人还提供披萨饼皮。你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。

方案三：SaaS，他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。

从左到右，自己承担的工作量（下图蓝色部分）越来越少，IaaS > PaaS > SaaS。


而在我们前端？如何理解PaaS? 同样的，我也举个例子。

我们会员有一个模块，比如会员标签。功能是查看会员标签，并可以创建标签。如下图：


我们想把这个功能作为一个服务输出。给其他业务用，无需再额外开发一套。

使用SaaS我们会怎么做？构建一个iframe，将整个页面嵌入。接入方不做任何改造，直接使用。显然，不可以这么用，姑且不说UI的不一致，不同业务使用的系统接口也不同。So, 我们需要 PaaS来做这个事，只做部分通用不变功能，预留其它可变功能给业务方定制。

所以，我理解的前端PaaS, 即 前端PaaS应该是 前端UI+业务逻辑 打包输出，作为一种服务形式，给其他业务使用。

如何做前端的PaaS
首先，第一步，要进行业务抽象。这也是所有谈及PaaS，最头疼也是最重要的一部分：业务抽象。业务抽象做的好，会大大提高平台的服务能力和适应场景。

继续上面的会员标签功能来说明。


我简单列举了下这个模块的抽象，但是实际上抽象可以更加具体，比如接口入参和出参不同，就需要一层适配，因此适配也需要抽象。

第二步，根据抽象进行编码和发布。编码不再多说，和我们往常的开发一样，只是要注意预留抽象能力在业务组件上。发布后，我们会得到发布后的模块，这一个页面和相关静态资源，相当于我们的前后端能力打包到一个可访问的页面上。

前端PaaS化需要解决的几个核心问题
业务发布成平台，单个业务能力可以作为模块输出

业务抽象，哪些固定，哪些开放？然后是如何开放？业务模块基于一套约束或者框架来开发

业务定制，模块在不同系统中可轻松定制

业务升级方便，最好能做到接入方无感知

业务解耦，既然是服务，必然不能对接入方有太多耦合

通过远程模块来实现前端PaaS
最近我尝试通过远程模块来做到了上面几点。但是还需要进一步的论证：

大家先点击看demo. 来熟悉一下：

主应用中嵌入子应用(这是最基本一个场景，页面级作为服务输出和使用)：

http://vy6vfy.coding-pages.com/index.html?stage=1#/remote

不同技术栈的前端应用嵌套使用( 前端框架繁多的情况下。不同框架集成使用也是要解决)：

http://vy6vfy.coding-pages.com/index.html?stage=2#/react-in-vue

同一模块在不同业务下的多态(很重要的功能，如何让输出的页面适配业务)：

http://vy6vfy.coding-pages.com/index.html?stage=3#/poly

父子应用的数据共享(很重要的功能，主应用的逻辑不需要耦合到子应用中)：

http://vy6vfy.coding-pages.com/index.html?stage=4#/share

什么是远程模块？和异步模块有啥区别？
远程模块本质上也是组件，只不过是大的业务组件，比如上面提到的会员标签整个业务，就可以当做一个组件。在服务输出领域，我更倾向于称之为远程模块。但是在开发时，我们知道它是组件即可。

之前的一篇博客介绍了一些微前端的方式。主要是讲述了如何在Vue项目中使用React项目的组件。这是基于组件均在本地的情况。今天介绍下远程模块(组件)的使用。

远程组件和异步组件最主要的一点区别是：异步组件是相对于同步组件的一种异步加载。也就是说组件都在当前项目仓库，为了解决组件打包体积过大带来网络加载过长，导致用户等待时间过久的体验问题。而采取的一种code split 解决办法。那么问题来了，既然我们可以基于路由，将本地组件通过code split 方式打包成多个包。那么这些包除了本地使用外。如果能够同时给其他项目使用。在其他项目里，可以引入远程项目的组件，当本地一样使用，这种集成方式听起来很新颖，也能解决很多问题。

为什么要用远程模块，iframe嵌套或者npm方式优劣分析？
首先说大家最耳熟能详的 iframe 嵌套方式。iframe方式本质上是将2个页面集成在了一起。因为隔离，能解决js污染，变量污染，js 沙箱运行。对于内外完全独立的场景来说，是合适的。但是通过 iframe 对外输出的是页面。外层页面对当前页面没有太多的干涉能力。如果有，需要内外协商定义 事件或者 通过 message 来实现。当然也无法直接使用外层页面内存中的对象。所以说iframe的内外隔离性很强，互动性差。

接着看去掉iframe的场景，方式是主页面动态构建dom, 引入另外系统的js, 该js 加载完成后自执行，渲染到指定的dom. 这里”指定的dom“ 会有一层依赖，即内外需要约定好 dom id 。这种方式去掉了iframe. 因此外部js在执行渲染期间，可以直接使用window上的对象或者方法。 但同时 外部js执行时也可能污染掉本地内存中的变量，甚至css等。隔离性差，互动性强。但是渲染需要约定。

到这里，我们发现上面2种方式，都有一个共同的缺点，就是如何渲染完全由外部js决定。外层不能控制和干涉。在一定程度上比较好理解，但能力有限。但实际场景中，外层真的完全不需要干涉内部渲染吗？设想一下这个场景，当项目作为一个子应用，需要给A, B 两个系统使用时，A，B系统均有自己全局错误交互方式，A系统使用弹窗告警。B系统使用Tip提醒。我们为了保证交互的一致性，需要子应用在A中使用弹窗，在B中使用Tip. 那我们项目该如何开发呢？开发2套不同的交互方式，分别给A，B用？如果父应用的交互方式发生了改变。那如何保持同步？不管是iframe还是加载远程js来渲染都解决不了这个问题。从场景上看，我们需要实现同一个应用在不同系统中的多态。从实现上看，我们要能够通过某种方式，控制到子应用在当前系统中的渲染。因此，今天介绍一种方式：远程组件。

远程组件解决的问题
续上面列举的场景，如果我们能够加载到远程js. 这个js并不立马执行渲染，而是暴露给我一个业务组件。此时，父页面拿到这个组件，就可以方便地在某个dom上执行渲染，不需要告知子应用，因此解决了父子依赖问题。然后，既然父页面拿到的是组件，那么我就可以当成一个本地组件来使用，我可以传入上下文(context)，也可以进一步进行封装，成为一个高阶组件，当然也可以通过属性，传递父页面的一些能力，比如全局错误交互方式，比如全局的网络请求库。当前页面的主题是dark还是light等。然后挂在到响应的dom上进行渲染，渲染完成后，我们将得到一个定制化的子应用。从而很好解决了我们的问题。但是有一点约束，子应用在开发时，在可能出现多态的地方，需要调用属性中传递过来的参数或者方法来实现，不需要本地来解决。(这里逻辑可以兼容，如果属性上传递有，就使用属性传递的数据，如果没有，就使用本地的逻辑)，也就是要求我们在开发子应用时，要进行一定的抽象，暴露一些外部可以控制的接口。

如何实现远程组件？

AIO是什么？
AIO，全称：all in one. 是一个企业级微前端框架。当前前端技术栈比较多，主流的 react, vue, 以及 ng，还有部分jquery项目等。在企业后台中，通常面临不同技术栈整合，以及相互间复用等问题。aio 希望能够解决此类融合问题。同时，对于新的微前端项目，aio 提供一套热插拔的解决方案。

当前，aio主要在处理 vue 和 react 项目互相嵌套使用问题，理论上也支持更多其他前端框架。

aio 目前正在开发测试阶段，希望广大内部项目接入使用，一起共建。

为什么要使用微前端？
在大型B端系统中，随着业务扩展，功能模块越来越多。比如之前供应链，其他模块是react, 部分是vue. 而报表部分，又使用了java后端渲染.  这就导致了：

打包慢，当前 crm-web build时间将近4分钟。

团队人员多，产品功能复杂，代码冲突频繁、影响面大。

发布影响范围大。理论上每次全量发布都有影响到全局的风险，涉及到通用更改的话，需要主流程回归。

项目对外扩展能力差。尤其在多系统合并时。单一项目需要统一技术栈，接口，命名，lint等，不然随着项目迭代，产品会变得庞大而难以维护。

实际项目经历：

在18年下半年，我们从屏芯那里迁移了供应链主数据和会员等产品。当时的项目均未支持微前端嵌入，因此在迁移这件事情上，我们前后端花费了2个月之久，涉及的工作主要是，接口整理改造，埋点改造，以及联调。而迁移的仅仅是 主数据 一个功能。过程中基本上把代码全review了一边，以免有未触及的地方。而如果我们的项目前端基于微前端模式开发。后端基于微服务开发。那么迁移过来时，仅仅需要的是在接入层集中做一次处理。不会涉及到业务逻辑的部分。迁移不但快速，而且可控。

另外一个问题就是框架不同。屏芯使用了vue开发，而我们这边是react .这个遗留问题一直到一年后的今天还存在。目前通过iframe整合了2个系统。使之看起来像一个系统，但本质上依然是2个系统，各自维护着2套菜单，权限，路由，等功能，体验上也一定瑕疵。当时我们能想到方式就是重构。基于一套技术栈重新开发。以便达到组件复用，通用逻辑复用和体验优化等目的。重构固然有好处，但是重构本身是一个耗时，且容易出现bug乃至故障的工作。并不是最佳方式。

因为我们一直在寻找一种组件跨框架复用，数据跨系统共享的前端整合方案，直到微前端出现。

AIO 相比其他微前端特性：
轻量，便于业务改造。相比UMI 提供的一套大而全的解决方案。AIO只做微前端系统之间整合，对于父子系统路由，打包，技术栈则不做硬性要求，便于改造。

支持跨框架的异步远程业务组件，目前仅支持react和vue，ng和jQuery暂时不支持，但是方案可以支持。

支持业务以组件形式整块儿或单个输出，似SaaS，集成在其他系统，并可以在不同系统中进行组件定制，使业务行为表现不一致，达到多态。

自动产出业务组件描述以及文档，方便服务发布和共享。

什么是远程模块？和异步模块有啥区别？
远程模块本质上也是组件，只不过是大的业务组件，比如上面提到的会员标签整个业务，就可以当做一个组件。在服务输出领域，我更倾向于称之为远程模块。但是在开发时，我们知道它是组件即可。

之前的一篇博客介绍了一些微前端的方式。主要是讲述了如何在Vue项目中使用React项目的组件。这是基于组件均在本地的情况。今天介绍下远程模块(组件)的使用。

远程组件和异步组件最主要的一点区别是：异步组件是相对于同步组件的一种异步加载。也就是说组件都在当前项目仓库，为了解决组件打包体积过大带来网络加载过长，导致用户等待时间过久的体验问题。而采取的一种code split 解决办法。那么问题来了，既然我们可以基于路由，将本地组件通过code split 方式打包成多个包。那么这些包除了本地使用外。如果能够同时给其他项目使用。在其他项目里，可以引入远程项目的组件，当本地一样使用，这种集成方式听起来很新颖，也能解决很多问题。

AIO为什么要用远程模块，iframe嵌套或者npm方式优劣分析？
首先说大家最耳熟能详的 iframe 嵌套方式。iframe方式本质上是将2个页面集成在了一起。因为隔离，能解决js污染，变量污染，js 沙箱运行。对于内外完全独立的场景来说，是合适的。但是通过 iframe 对外输出的是页面。外层页面对当前页面没有太多的干涉能力。如果有，需要内外协商定义 事件或者 通过 message 来实现。当然也无法直接使用外层页面内存中的对象。所以说iframe的内外隔离性很强，互动性差。

接着看去掉iframe的场景，方式是主页面动态构建dom, 引入另外系统的js, 该js 加载完成后自执行，渲染到指定的dom. 这里”指定的dom“ 会有一层依赖，即内外需要约定好 dom id 。这种方式去掉了iframe. 因此外部js在执行渲染期间，可以直接使用window上的对象或者方法。 但同时 外部js执行时也可能污染掉本地内存中的变量，甚至css等。隔离性差，互动性强。但是渲染需要约定。

到这里，我们发现上面2种方式，都有一个共同的缺点，就是如何渲染完全由外部js决定。外层不能控制和干涉。在一定程度上比较好理解，但能力有限。但实际场景中，外层真的完全不需要干涉内部渲染吗？设想一下这个场景，当项目作为一个子应用，需要给A, B 两个系统使用时，A，B系统均有自己全局错误交互方式，A系统使用弹窗告警。B系统使用Tip提醒。我们为了保证交互的一致性，需要子应用在A中使用弹窗，在B中使用Tip. 那我们项目该如何开发呢？开发2套不同的交互方式，分别给A，B用？如果父应用的交互方式发生了改变。那如何保持同步？不管是iframe还是加载远程js来渲染都解决不了这个问题。从场景上看，我们需要实现同一个应用在不同系统中的多态。从实现上看，我们要能够通过某种方式，控制到子应用在当前系统中的渲染。因此，今天介绍一种方式：远程组件。

远程组件解决的问题
如果我们能够加载到远程js. 这个js并不立马执行渲染，而是暴露给我一个业务组件。此时，父页面拿到这个组件，就可以方便地在某个dom上执行渲染，不需要告知子应用，因此解决了父子依赖问题。然后，既然父页面拿到的是组件，那么我就可以当成一个本地组件来使用，我可以传入上下文(context)，也可以进一步进行封装，成为一个高阶组件，当然也可以通过属性，传递父页面的一些能力，比如全局错误交互方式，比如全局的网络请求库。当前页面的主题是dark还是light等。然后挂在到响应的dom上进行渲染，渲染完成后，我们将得到一个定制化的子应用。从而很好解决了我们的问题。但是有一点约束，子应用在开发时，在可能出现多态的地方，需要调用属性中传递过来的参数或者方法来实现，不需要本地来解决。(这里逻辑可以兼容，如果属性上传递有，就使用属性传递的数据，如果没有，就使用本地的逻辑)，也就是要求我们在开发子应用时，要进行一定的抽象，暴露一些外部可以控制的接口。

通过远程模块来实现微前端demo:
最近我尝试通过远程模块来做到了上面几点。但是还需要进一步的论证：

大家先点击看demo. 来熟悉一下：

主应用中嵌入子应用(这是最基本一个场景，页面级作为服务输出和使用)：

http://vy6vfy.coding-pages.com/index.html?stage=1#/remote

不同技术栈的前端应用嵌套使用( 前端框架繁多的情况下。不同框架集成使用也是要解决)：

http://vy6vfy.coding-pages.com/index.html?stage=2#/react-in-vue

同一模块在不同业务下的多态(很重要的功能，如何让输出的页面适配业务)：

http://vy6vfy.coding-pages.com/index.html?stage=3#/poly

父子应用的数据共享(很重要的功能，主应用的逻辑不需要耦合到子应用中)：

http://vy6vfy.coding-pages.com/index.html?stage=4#/share



当前会员项目调研分析
当前主要有2个项目。专业版(屏芯vue迁移)， 智能版(基于专业版的重制版，优化了部分逻辑，主题适配智能版。并集成进rms)。

重构版 在保证业务逻辑不变的情况下。将从底层进行重建，基于react. 使用 typescript, 使用团队统一lint和sonar规则。与团队技术栈统一。

时间：重构时间大概持续半年(期间要保持当前2个项目的正常迭代)

人员：会员组同学3人 

阶段：


阶段1： 智能版需求分批重构并替换掉目前的智能版，直到整个项目完成迁移

阶段2：专业版6.30后需求和改动合并进重构完成后的智能版。

至此完成智能版重构。

后续：

对于后续的专业版和智能版，需求开发2次问题。调研阶段3的可行性

阶段3：新功能只需要开发一次。可在2个版本系统中使用。因此在新的架构中，提前考虑该问题，预留改动的空间

重构面临的问题
1 重构中老业务升级和bug修复。

方案： 在原有项目中正常迭代。新的更新再在新的组件中更新一次。目前会员老业务升级和bug修复不多。

2 迭代过程中新需求

方案：专业版的需求使用vue开发。目前智能版暂时未同步专业版需求(这是业务痛点)，未来需要人工迁移到智能版。后端也面临一样的问题。

我们将尝试在 智能版和重构版的需求使用react开发一次，跨系统复用。达到开发一次，多系统使用。

3 重构后

重构完成后将替换现在智能版项目。

如果可以的话，以后的需求智能版和专业版只需要开发一次。这个要根据需求来定需要是通用且独立的需求，比如储值授信。

几种微前端方案的列举和思考
重构过程比较长，所以重构是一个持续过程，完成一块功能，就迁移到智能版。所以采用微前端的方式集成。主项目不发布，功能热替换。

方案

方案核心实现

优点

缺点

iframe

iframe内嵌页面

最简单的实现

内外独立的2个系统，

系统间数据共享，通信等很多问题都需要解决

rms 运营中心方案

主项目创建dom

主项目请求子项目描述文件

主项目加载子项目静态资源

子项目渲染在同id的dom

结束

主项目动态加载子项目

实现了微前端

实现简单，好理解

父子项目数据无法直接共享

父项目无法控制子项目渲染的细节。

父子项目有很多约定。

子组件单独无法使用。(如果依赖外层提供的数据的话)

远程模块(组件)

主项目请求子项目描述文件

主项目动态获取子模块入口 js 和 css，

主项目在promise中获取子模块

主项目传入props 和 context 给子模块。(也可以基于子模块再次进行上层封装), 此步因具体业务而定，可省略。

主项目渲染子模块。

结束

主项目动态加载子项目

实现了微前端

父子项目数据可以直接通过 和 context传递，不需要额外技术

父页面可以控制子页面的渲染(位置，时机)。甚至可以通用组件再次包装。

可以实现不同系统，页面的多态

实现稍微复杂，需要一定理解成本

远程模块(组件)一些质疑
为啥不封装npm的业务组件，再彼此系统中使用。

业务组件变化频繁，一般不抽象组件使用。另外npm组件更新，需要使用此组件的系统分别发布升级，会造成线上系统频繁发布，无关的功能也会被频繁发布。

远程模块的改造成本多大，对业务入侵？

使用远程模块方案，只对编译阶段有影响，会额外编译一个目录存放本次业务组件，发布后供其他系统远程获取。自身系统的开发形式和发布形式不约束。但要保证组件是纯组件(尽量不在组件内部依赖全局变量或者数据，保证组件在提供正确 props和context 下即可正常使用)，如果有依赖需求，通过 props 或者 context  从外部进行传递。事实上，这点也是我们正常形式开发时要遵守的一点。

为啥不用时老师的方式

会员portm的方式也可以实现。但是正如缺点描述那样，对父子有约定，比如组件渲染的dom id 要约定，子组件的全局数据怎么获取和更新。子组件在开发时路由怎么控制？还有一个问题，子页面的多态无法实现。比如我们组件有2套主题。需要根据父主题而定。通过远程模块，子组件在开发时可以直接根据上下文中的主题内容来渲染自身样式。父组件在渲染时只要包装上context即可。在我们会员系统里，全局的用户信息，菜单权限等，子组件开发时不需要管怎么来的，只需要控制怎么渲染即可。

组件重复的问题？父子应用重复？子应用多个会重复吗？

本着一个原则：微前端尽量减少父子应用之间的耦合。换句话说，单拿出来，应用是个独立的应用，集成后，又可以做为子应用。这是我们设计的理念。在开发时候，开发同学同样不感知我应用最终如何呈现，统一当做一个独立应用开发。所以，父子应用的公共组件不贡献，也不应该共享。(不然会有版本耦合)

子应用独立打包，webpack会抽取子应用组件的公共组件，在我们引入子应用的main脚本时，相关vender会同时被加载。而且只会加载一次。（这点webpack会帮我们实现）

方案设计
整个方案的核心思想就是将webpack 基于组件 code split， 将传统的同项目异步加载，改为异项目异步加载。

图例：

前置要求：

✅A, B 项目依赖react 版本保持一致。

✅打包后包名要不能重复，可以通过编译控制。

简单的实现方案：

A业务正常开发自身项目。

编译时，除了A正常打包外，在build中打包一个目录。里面是A组件对外提供的业务组件。

打包方式，使用webpack的 code split 即可：

代码块
JavaScript
// 将组件输出到window
window.remoteModule = (name: string) => {
  if (name === "home") {
    return import(/* webpackChunkName: "smarts_home" */ './pages/Home');
  }
  if (name === "test") {
    return import(/* webpackChunkName: "smarts_test" */ './pages/Test');
  }
}
如下图：

 

其中，main是入口文件，给B项目依赖。smarts_x.bundle.js 为组件。

B项目中加载后，在入口处动态引入A入口文件(此时，A种的组件还未加载)：

代码块
JavaScript
function loadRemoteModule = (src) => {
  var script = document.createElement('script');
  script.charset = 'utf-8';
  script.timeout = 2000;
  script.setAttribute('crossorigin', 'anonymous')
  script.setAttribute('type', 'text/javascript')
  script.crossorigin="anonymous"
  document.head.appendChild(script);
  script.src = src;
}
​
B项目异步引入远程模块A中的组件（webpack将动态加载该组件的js文件和它的依赖）：

代码块
JavaScript
getRemoteComponent('home').then((Home) => {
  this.setState({
    el: Home.default || Home,
  })
})
​
getRemoteComponent = (name: string) => {
   return Promise.all([
      window.remoteModule(name),
    ])
}
​
 render() {
    const Com = this.state.el;
    const Context = this.state.context;
    return <div>
        <hr/>
        <Context value={{user: 'yanggaofei'}}> //指定异步组件的上下文
           <Com id={1}/> // 传递属性
        </Context>
    </div>
}
重构的技术价值和产出
重构不是简单的新瓶装旧药，也不是无意义的重复建设。基于当前版本现有问题的解决，同时激励自我成长。我们在改造完成后要达到以下目标：

序号

1

推行新的react 版本以及新特性在项目落地，沉淀和积累经验。系列文章： 经验积累 (每个人都要有)

2

梳理业务。优化代码中的多处冗余。

3

积累大型项目微前端整合的经验， 产出通用技术方案/技术博客

4

对团队代码检查sonar配置的更新 



