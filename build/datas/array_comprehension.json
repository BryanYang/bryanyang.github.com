[
  "## ES6一些知识",
  "原文摘自 阮一峰的博客 [链接](http://es6.ruanyifeng.com/#docs/array)",
  "-----",
  "## 数组推导",
  "**数组推导**（array comprehension）提供简洁写法，允许直接通过现有数组生成新数组。这项功能本来是要放入ES6的，但是TC39委员会想继续完善这项功能，让其支持所有数据结构（内部调用iterator对象），不像现在只支持数组，所以就把它推迟到了ES7。Babel转码器已经支持这个功能。",
  "```var a1 = [1, 2, 3, 4];\nvar a2 = [for (i of a1) i * 2];\n\na2 // [2, 4, 6, 8]\n```",
  "上面代码表示，通过`for...of`结构，数组`a2`直接在`a1`的基础上生成。",
  "注意，数组推导中，`for...of`结构总是写在最前面，返回的表达式写在最后面。",
  "for...of后面还可以附加if语句，用来设定循环的限制条件。",
  "```var years = [ 1954, 1974, 1990, 2006, 2010, 2014 ];\n\n[for (year of years) if (year > 2000) year];\n// [ 2006, 2010, 2014 ]\n\n[for (year of years) if (year > 2000) if(year < 2010) year];\n// [ 2006]\n\n[for (year of years) if (year > 2000 && year < 2010) year];\n// [ 2006]\n```",
  "上面代码表明，if语句要写在`for...of`与返回的表达式之间，而且可以多个`if`语句连用。",
  "下面是另一个例子。",
  "```var customers = [\n  {\n    name: 'Jack',\n    age: 25,\n    city: 'New York'\n  },\n  {\n    name: 'Peter',\n    age: 30,\n    city: 'Seattle'\n  }\n];\n\nvar results = [\n  for (c of customers)\n    if (c.city == \"Seattle\")\n      { name: c.name, age: c.age }\n];\nresults // { name: \"Peter\", age: 30 }\n```",
  "数组推导可以替代`map`和`filter`方法。",
  "```[for (i of [1, 2, 3]) i * i];\n// 等价于\n[1, 2, 3].map(function (i) { return i * i });\n\n[for (i of [1,4,2,3,-8]) if (i < 3) i];\n// 等价于\n[1,4,2,3,-8].filter(function(i) { return i < 3 });\n```",
  "上面代码说明，模拟map功能只要单纯的`for...of`循环就行了，模拟`filter`功能除了`for...of`循环，还必须加上`if`语句。",
  "在一个数组推导中，还可以使用多个`for...of`结构，构成多重循环。",
  "```var a1 = ['x1', 'y1'];\nvar a2 = ['x2', 'y2'];\nvar a3 = ['x3', 'y3'];\n\n[for (s of a1) for (w of a2) for (r of a3) console.log(s + w + r)];\n// x1x2x3\n// x1x2y3\n// x1y2x3\n// x1y2y3\n// y1x2x3\n// y1x2y3\n// y1y2x3\n// y1y2y3\n```",
  "上面代码在一个数组推导之中，使用了三个`for...of`结构。",
  "需要注意的是，数组推导的方括号构成了一个单独的作用域，在这个方括号中声明的变量类似于使用let语句声明的变量。",
  "由于字符串可以视为数组，因此字符串也可以直接用于数组推导。",
  "```[for (c of 'abcde') if (/[aeiou]/.test(c)) c].join('') // 'ae'\n\n[for (c of 'abcde') c+'0'].join('') // 'a0b0c0d0e0'\n```",
  "上面代码使用了数组推导，对字符串进行处理。",
  "> ** 数组推导需要注意的地方是，新数组会立即在内存中生成。这时，如果原数组是一个很大的数组，将会非常耗费内存。**\n",
  "## 编程风格",
  "### 块级作用域",
  "（1）let取代var",
  "ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。",
  "```'use strict';\n\nif (true) {\n  let x = 'hello';\n}\n\nfor (let i = 0; i < 10; i++) {\n  console.log(i);\n}\n```",
  "上面代码如果用var替代let，实际上就声明了一个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。",
  "var命令存在变量提升效用，let命令没有这个问题。",
  "```'use strict';\n\nif(true) {\n  console.log(x); // ReferenceError\n  let x = 'hello';\n}\n```",
  "上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。",
  "所以，建议不再使用var命令，而是使用let命令取代。",
  "",
  "（2）全局常量和线程安全",
  "在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。这符合函数式编程思想，有利于将来的分布式运算。",
  "```// bad\nvar a = 1, b = 2, c = 3;\n\n// good\nconst a = 1;\nconst b = 2;\nconst c = 3;\n\n// best\nconst [a, b, c] = [1, 2, 3];\n```",
  "const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。",
  "所有的函数都应该设置为常量。",
  "长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。",
  "",
  "（3）严格模式",
  "V8引擎只在严格模式之下，支持let。结合前两点，这实际上意味着，将来所有的编程都是针对严格模式的。",
  "",
  "字符串",
  "静态字符串一律使用`单引号`或`反引号`，不使用`双引号`。动态字符串使用`反引号`。",
  "```// bad\nconst a = \"foobar\";\nconst b = 'foo' + a + 'bar';\n\n// acceptable\nconst c = `foobar`;\n\n// good\nconst a = 'foobar';\nconst b = `foo${a}bar`;\nconst c = 'foobar';\n```",
  "解构赋值",
  "使用数组成员对变量赋值时，优先使用解构赋值。",
  "```const arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n```",
  "函数的参数如果是对象的成员，优先使用解构赋值。",
  "```// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n}\n\n// good\nfunction getFullName(obj) {\n  const { firstName, lastName } = obj;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n}\n```",
  "如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。",
  "```// bad\nfunction processInput(input) {\n  return [left, right, top, bottom];\n}\n\n// good\nfunction processInput(input) {\n  return { left, right, top, bottom };\n}\n\nconst { left, right } = processInput(input);\n```",
  "对象",
  "单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。",
  "```// bad\nconst a = { k1: v1, k2: v2, };\nconst b = {\n  k1: v1,\n  k2: v2\n};\n\n// good\nconst a = { k1: v1, k2: v2 };\nconst b = {\n  k1: v1,\n  k2: v2,\n};\n```",
  "对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。",
  "```// bad\nconst a = {};\na.x = 3;\n\n// if reshape unavoidable\nconst a = {};\nObject.assign(a, { x: 3 });\n\n// good\nconst a = { x: null };\na.x = 3;\n```",
  "如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。",
  "```// bad\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n  [getKey('enabled')]: true,\n};\n```",
  "上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。",
  "另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。",
  "```var ref = 'some value';\n\n// bad\nconst atom = {\n  ref: ref,\n\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  ref,\n\n  value: 1,\n\n  addValue(value) {\n    return atom.value + value;\n  },\n};\n```",
  "数组",
  "使用扩展运算符（`...`）拷贝数组。",
  "```// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i++) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```",
  "使用`Array.from`方法，将类似数组的对象转为数组。",
  "```const foo = document.querySelectorAll('.foo');\nconst nodes = Array.from(foo);\n```",
  "函数",
  "立即执行函数可以写成箭头函数的形式。",
  "```(() => {\n  console.log('Welcome to the Internet.');\n})();\n```",
  "那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。",
  "```// bad\n[1, 2, 3].map(function (x) {\n  return x * x;\n});\n\n// good\n[1, 2, 3].map((x) => {\n  return x * x;\n});\n\n// best\n[1, 2, 3].map(x => x * x);\n```",
  "**箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。**",
  "```// bad\nconst self = this;\nconst boundMethod = function(...params) {\n  return method.apply(self, params);\n}\n\n// acceptable\nconst boundMethod = method.bind(this);\n\n// best\nconst boundMethod = (...params) => method.apply(this, params)**;\n```",
  "简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。",
  "所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。",
  "```// bad\nfunction divide(a, b, option = false ) {\n}\n\n// good\nfunction divide(a, b, { option = false } = {}) {\n}\n```",
  "不要在函数体内使用arguments变量，使用rest运算符（...）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。",
  "```// bad\nfunction concatenateAll() {\n  const args = Array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}\n```",
  "使用默认值语法设置函数参数的默认值。",
  "```// bad\nfunction handleThings(opts) {\n  opts = opts || {};\n}\n\n// good\nfunction handleThings(opts = {}) {\n  // ...\n}\n```",
  "Map结构",
  "注意区分Object和Map，只有模拟实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。",
  "```let map = new Map(arr);\n\nfor (let key of map.keys()) {\n  console.log(key);\n}\n\nfor (let value of map.values()) {\n  console.log(value);\n}\n\nfor (let item of map.entries()) {\n  console.log(item[0], item[1]);\n}\n```",
  "Class",
  "总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。",
  "```// bad\nfunction Queue(contents = []) {\n  this._queue = [...contents];\n}\nQueue.prototype.pop = function() {\n  const value = this._queue[0];\n  this._queue.splice(0, 1);\n  return value;\n}\n\n// good\nclass Queue {\n  constructor(contents = []) {\n    this._queue = [...contents];\n  }\n  pop() {\n    const value = this._queue[0];\n    this._queue.splice(0, 1);\n    return value;\n  }\n}\n```",
  "使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。",
  "```// bad\nconst inherits = require('inherits');\nfunction PeekableQueue(contents) {\n  Queue.apply(this, contents);\n}\ninherits(PeekableQueue, Queue);\nPeekableQueue.prototype.peek = function() {\n  return this._queue[0];\n}\n\n// good\nclass PeekableQueue extends Queue {\n  peek() {\n    return this._queue[0];\n  }\n}\n```",
  "模块",
  "首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。",
  "```// bad\nconst moduleA = require('moduleA');\nconst func1 = moduleA.func1;\nconst func2 = moduleA.func2;\n\n// good\nimport { func1, func2 } from 'moduleA';\n```",
  "使用export取代module.exports。",
  "```// commonJS的写法\nvar React = require('react');\n\nvar Breadcrumbs = React.createClass({\n  render() {\n    return <nav />;\n  }\n});\n\nmodule.exports = Breadcrumbs;\n\n// ES6的写法\nimport React from 'react';\n\nconst Breadcrumbs = React.createClass({\n  render() {\n    return <nav />;\n  }\n});\n\nexport default Breadcrumbs\n```",
  "**如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。**",
  "不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。",
  "```// bad\nimport * as myObject './importModule';\n\n// good\nimport myObject from './importModule';\n```",
  "如果模块默认输出一个函数，函数名的首字母应该小写。",
  "```function makeStyleGuide() {\n}\n\nexport default makeStyleGuide;\n```",
  "如果模块默认输出一个对象，对象名的首字母应该大写。",
  "```const StyleGuide = {\n  es6: {\n  }\n};\n\nexport default StyleGuide;\n```",
  "",
  "ESLint的使用",
  "ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。",
  "",
  "首先，安装ESLint。",
  "`$ npm i -g eslint`",
  "然后，安装Airbnb语法规则。",
  "`$ npm i -g eslint-config-airbnb`",
  "最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。",
  "``{\n  \"extends\": \"eslint-config-airbnb\"\n}\n``",
  "现在就可以检查，当前项目的代码是否符合预设的规则。",
  "index.js文件的代码如下。",
  "```var unusued = 'I have no purpose!';\n\nfunction greet() {\n    var message = 'Hello, World!';\n    alert(message);\n}\n\ngreet();\n```",
  "使用ESLint检查这个文件。",
  "``$ eslint index.js\nindex.js\n  1:5  error  unusued is defined but never used                 no-unused-vars\n  4:5  error  Expected indentation of 2 characters but found 4  indent\n  5:5  error  Expected indentation of 2 characters but found 4  indent\n\n✖ 3 problems (3 errors, 0 warnings)\n``",
  "上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。",
  "babel有eslint插件，可以在打包时候检查语法。"
]